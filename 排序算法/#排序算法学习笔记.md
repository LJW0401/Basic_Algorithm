# 排序算法的一些学习笔记
## 目录
[冒泡排序](#冒泡排序)<br>
[选择排序](#选择排序)<br>
[插入排序](#插入排序)<br>
[快速排序](#快速排序)<br>

[总体对比](#总体对比)<br>

## 冒泡排序
代码详见  [冒泡排序.cpp](https://github.com/LJW0401/Basic_Algorithm/blob/main/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.cpp)

* 原始冒泡排序

    算法实现：<br>
    通过一次次交换来把待排序区域中的最值移动到被排序的位置，用2重循环即可实现。
* 第1次改进

    通过设置标志位，判断是否有交换行为的发生。<br>
    如果有，那么继续排序，没有则结束排序。

* 第2次改进

    通过在一次排序中前后2次冒泡，达到在一次过程中同确定最大值和最小值。

* 测试效果

    以下列出几次测试时得到的数据：<br>
    |改进次数| 运行时间|数据量| 运行时间 |数据量| 运行时间 |数据量|
    |:-----:|:-------:|:---:|:-------:|:----:|:-------:|:----:|
    |0      | 1785 ms |25000| 1792 ms |25000 | 7484 ms |50000 |
    |1      | 1812 ms |25000| 1757 ms |25000 | 7541 ms |50000 |
    |2      | 1525 ms |25000| 1501 ms |25000 | 6163 ms |50000 |

    在测试中发现，对于随机生成的无规律数据<br>
    第1次改进作用有限，甚至会降低效率。<br>
    第2次改进作用在数据量大的情况下还是比较明显的。


## 选择排序
代码详见  [选择排序.cpp](https://github.com/LJW0401/Basic_Algorithm/blob/main/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.cpp)

* 原始插入排序

    算法实现：<br>
    通过在待排序区域寻找最值并放置于被排序位置来实现排序。

* 第1次改进

    在一次寻找的时候同时寻找最大值和最小值并确定下来。<br>
    <font color=#ff3333>注：写代码时在交换时要小心三者同时交换时的顺序及内容变化。</font>

* 测试效果

    以下列出几次测试时得到的数据：<br>
    |改进次数|运行时间|数据量|运行时间 |数据量|
    |:-----:|:-----:|:----:|:------:|:----:|
    |0      |2516 ms|50000 |10206 ms|100000|
    |1      |1526 ms|50000 |6092 ms |100000|

    在测试的时候发现改进后能有效提高运行效率，效率的提高略小于一倍。

## 插入排序
代码详见  [插入排序.cpp](https://github.com/LJW0401/Basic_Algorithm/blob/main/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.cpp)

* 原始插入排序

    算法实现：<br>
    将被排序对象插入到有序区域，持续向前移动，直至被排序对象的值在前后2个元素的值之间。

* 第1次改进

    用对分查找，找到合适位置后直接插入到对应位置。

* 测试效果

    以下列出几次测试时得到的数据：<br>
    |改进次数|运行时间|数据量|运行时间 |数据量|
    |:-----:|:-----:|:----:|:------:|:----:|
    |0      |2336 ms|50000 |9391 ms |100000|
    |1      |1045 ms|50000 |4172 ms |100000|

    从中我们发现改进后的插入排序效率有效的提高，翻了一倍左右。

## 快速排序
代码详见  [快速排序.cpp](https://github.com/LJW0401/Basic_Algorithm/blob/main/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.cpp)

* 原始快速排序

* 改进

    这种降维打击的方法就不用改进了吧。

* 测试效果

    这玩意太强大了，直接上数据！！！<br>
    以下列出几次测试时得到的数据：<br>
    |运行时间|数据量|
    |:-----:|:----:|
    |11 ms  |100000|
    |110 ms |1000000|
    |1150 ms|10000000|

## 总体对比
代码详见  [各种排序算法之间的对比.cpp](https://github.com/LJW0401/Basic_Algorithm/blob/main/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94.cpp)

我们使用上文中所出现的各种排序算法的优化版本来做对比。

* 测试效果

    以下列出几次测试时得到的数据：<br>
    |排序算法|运行时间|数据量|
    |:-----:|:-----:|:----:|
    |冒泡排序|5588 ms|50000|
    |选择排序|1542 ms|50000|
    |插入排序|1041 ms|50000|
    |快速排序|6 ms   |50000|

    观察数据可以发现快速排序实在是太过于强大，几乎是一个降维打击的存在，实力碾压其他各种算法。

    冒泡排序由于其交换次数实在过多，即便进行了各种优化，还是难以将运行效率足够的提高。
